type Proxy @entity {
  "Proxy ID is always '0'. There's only"
  id: ID!

  "Current implementation is represented by a link to the current Exchange entity"
  currentImplementation: Exchange

  "List of all historical Exchange entities (implementations)"
  implementations: [Exchange!]! @derivedFrom(field: "proxy")

  "Total amount of block processed"
  blockCount: BigInt!
}

type Exchange @entity {
  "Address of the exchange"
  id: ID!

  "Proxy link. Used to generate derived array of implementations."
  proxy: Proxy!

  "List of all tokens supported during the time this Exchange was the current implementation"
  tokens: [Token!]! @derivedFrom(field: "exchange")
}

type Token @entity {
  "Internal ID of the token within Loopring"
  id: ID!

  "Exchange implementation active when the token was registered"
  exchange: Exchange!

  "Address of the token within the Ethereum network"
  address: Bytes!

  decimals: Int!

  name: String!

  symbol: String!

  "Total traded volume for this token across all token pairs. Denominated in it's own currency"
  tradedVolume: BigInt!
}

type Pair @entity {
  "ID is recreated following the next pattern to standardize pair IDs: <LOWEST Token ID>-<HIGHEST Token ID>"
  id: ID!

  token0: Token!

  token1: Token!

  "Last price of Token 0. Denominated in Token 1"
  token0Price: BigInt!

  "Last price of Token 1. Denominated in Token 0"
  token1Price: BigInt!

  "Total traded volume of token 0 within this pair. Denominated in it's own currency"
  tradedVolumeToken0: BigInt!

  "Total traded volume of token 1 within this pair. Denominated in it's own currency"
  tradedVolumeToken1: BigInt!

  trades: [SpotTrade!]! @derivedFrom(field: "pair")
}

type Block @entity {
  id: ID!

  txHash: String!

  gasUsed: BigInt!

  gasPrice: BigInt!

  height: BigInt!

  timestamp: BigInt!

  blockHash: String!

  # Raw block data
  blockType: Int!
  blockSize: Int!
  blockVersion: Int!
  data: String!
  proof: [BigInt!]!
  storeBlockInfoOnchain: Boolean!
  offchainData: Bytes!

  # Parsed data from block
  protocolFeeTakerBips: Int!
  protocolFeeMakerBips: Int!
  numConditionalTransactions: Int!
  operatorAccountID: Int!

  operatorAccount: Account!

  transactions: [Transaction!]! @derivedFrom(field: "block")
}

interface Account {
  id: ID!

  address: Bytes!

  balances: [AccountTokenBalance!]! @derivedFrom(field: "account")

  createdAt: Transaction!

  lastUpdatedAt: Transaction!
}

type User implements Account @entity {
  "Internal ID used in the L2 transactions"
  id: ID!

  address: Bytes!

  publicKey: String

  balances: [AccountTokenBalance!]! @derivedFrom(field: "account")

  createdAt: Transaction!

  lastUpdatedAt: Transaction!
}

type Pool implements Account @entity {
  "Internal ID used in the L2 transactions"
  id: ID!

  address: Bytes!

  feeBipsAMM: Int

  balances: [AccountTokenBalance!]! @derivedFrom(field: "account")

  createdAt: Transaction!

  lastUpdatedAt: Transaction!
}

type ProtocolAccount implements Account @entity {
  "ID is always 0 since there's only a single ProtocolAccount and uses the reserved id 0"
  id: ID!

  address: Bytes!

  balances: [AccountTokenBalance!]! @derivedFrom(field: "account")

  createdAt: Transaction!

  lastUpdatedAt: Transaction!
}

type AccountTokenBalance @entity {
  "ID is recreated following this pattern: <ACCOUNT ID>-<TOKEN ID>. Example: 10001-1"
  id: ID!

  balance: BigInt!

  "Link to the Account entity. Can be a Pool or User entity"
  account: Account!

  "Link to the Token entity. Holds all details of the token itself."
  token: Token!
}

interface Transaction {
  "All transactions IDs follow the same pattern: <BLOCK ID>-<TX INDEX>"
  id: ID!

  "Hex string representation of the encoded L2 data for this Transaction"
  data: String!

  "Link to the Block entity where this Transaction took place"
  block: Block!
}

type Deposit implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  toAccount: Account!

  token: Token!

  # Raw data parsed from the L2 data
  to: String!
  toAccountID: Int!
  tokenID: Int!
  amount: BigInt!
}

type Withdrawal implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  fromAccount: Account!

  token: Token!

  feeToken: Token!

  # Raw data parsed from the L2 data
  type: Int!
  from: String!
  fromAccountID: Int!
  tokenID: Int!
  amount: BigInt!
  feeTokenID: Int!
  fee: BigInt!
  onchainDataHash: String!
  storageID: Int!
}

type Transfer implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  fromAccount: Account!

  toAccount: Account!

  token: Token!

  feeToken: Token!

  # Raw data parsed from the L2 data
  type: Int!
  accountFromID: Int!
  accountToID: Int!
  tokenID: Int!
  amount: BigInt!
  feeTokenID: Int!
  fee: BigInt!
  storageID: Int!
  from: String!
  to: String!
}

type SpotTrade implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  "Account A data"
  accountA: Account!
  "Account B data"
  accountB: Account!

  "Token A. Supplied by Account A"
  tokenA: Token!
  "Token B. Supplied by Account B"
  tokenB: Token!

  "Price for 1 unit of token A for this trade. Denominated in token B"
  tokenAPrice: BigInt!
  "Price for 1 unit of token B for this trade. Denominated in token A"
  tokenBPrice: BigInt!

  pair: Pair!

  # Raw data parsed from the L2 data
  storageIdA: Int!
  storageIdB: Int!

  accountIdA: Int!
  accountIdB: Int!

  tokenIDA: Int!
  tokenIDB: Int!

  fFillSA: Int!
  fFillSB: Int!

  "Amount of token A sold by Account A"
  fillSA: BigInt!
  "Amount of token B sold by Account B"
  fillSB: BigInt!

  orderDataA: Int!
  orderDataB: Int!

  limitMaskA: BigInt!
  feeBipsA: BigInt!
  fillAmountBorSA: Boolean!

  limitMaskB: BigInt!
  feeBipsB: BigInt!
  fillAmountBorSB: Boolean!

  "Amount of token B bought by Account A"
  fillBA: BigInt!
  "Amount of token A bought by Account B"
  fillBB: BigInt!

  "Fee paid by Account A with Token B"
  feeA: BigInt!
  protocolFeeA: BigInt!

  "Fee paid by Account B with token A"
  feeB: BigInt!
  protocolFeeB: BigInt!
}

type AccountUpdate implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  user: User!

  feeToken: Token!

  # Raw data parsed from the L2 data
  updateType: Int!
  owner: String!
  accountID: Int!
  feeTokenID: Int!
  fee: BigInt!
  publicKey: String!
  nonce: Int!
}

type AmmUpdate implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  pool: Pool!

  # Raw data parsed from the L2 data
  owner: String!
  accountID: Int!
  tokenID: Int!
  feeBips: Int!
  tokenWeight: BigInt!
  nonce: Int!
  balance: BigInt!
}

type SignatureVerification implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  account: Account!

  # Raw data parsed from the L2 data
  owner: String!
  accountID: Int!
  verificationData: String!
}
