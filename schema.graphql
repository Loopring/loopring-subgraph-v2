type Proxy @entity {
  "Proxy ID is always '0'. There's only"
  id: ID!

  "Current implementation is represented by a link to the current Exchange entity"
  currentImplementation: Exchange

  "List of all historical Exchange entities (implementations)"
  implementations: [Exchange!]! @derivedFrom(field:"proxy")

  "Total amount of block processed"
  blockCount: BigInt!
}

type Exchange @entity {
  "Address of the exchange"
  id: ID!

  proxy: Proxy!

  "List of all tokens supported during the time this Exchange was the current implementation"
  tokens: [Token!]! @derivedFrom(field: "exchange")
}

type Token @entity {
  id: ID!

  "Exchange implementation active when the token was registered"
  exchange: Exchange!

  address: Bytes!

  decimals: Int!

  name: String!

  symbol: String!
}

type Block @entity {
  id: ID!

  operator: String!

  txHash: String!

  gasUsed: BigInt!

  gasPrice: BigInt!

  height: BigInt!

  timestamp: BigInt!

  blockHash: String!

  # Raw block data
  blockType: Int!
  blockSize: Int!
  blockVersion: Int!
  data: String!
  proof: [BigInt!]!
  storeBlockInfoOnchain: Boolean!
  offchainData: Bytes!

  # Parsed data from block
  protocolFeeTakerBips: String!
  protocolFeeMakerBips: String!
  numConditionalTransactions: String!
  operatorAccountID: String!

  transactions: [Transaction!]! @derivedFrom(field:"block")
}

type Account @entity {
  "Internal ID used in the L2 transactions"
  id: ID!

  address: Bytes!
}

interface Transaction {
  "All transactions IDs follow the same pattern: <BLOCK ID>-<TX INDEX>"
  id: ID!

  data: String!

  block: Block!
}

type Deposit implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  to: String! # Not sure what this represents yet
  toAccountID: Int! # Should link to Account entity in the future
  tokenID: Int! # Should link to Token entity
  amount: BigInt!
}

type SpotTrade implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!


  storageIdA: Int!
  storageIdB: Int!

  accountIdA: Int!
  accountIdB: Int!

  tokenA: Int!
  tokenB: Int!

  fFillSA: Int!
  fFillSB: Int!

  orderDataA: Int!
  orderDataB: Int!
}

type Transfer implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  type: Int!
  accountFromID: Int!
  accountToID: Int!
  tokenID: Int!
  amount: Int!
  feeTokenID: Int!
  fee: Int!
  storageID: Int!
  from: String!
  to: String!
}

type Withdrawal implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  type: Int!
  from: String!
  fromAccountID: Int!
  tokenID: Int!
  amount: BigInt!
  feeTokenID: Int!
  fee: Int!
  onchainDataHash: String!
  storageID: Int!
}

type AccountUpdate implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  updateType: Int!
  owner: String!
  accountID: Int!
  feeTokenID: Int!
  fee: Int!
  publicKey: String!
  nonce: Int!
}

type AmmUpdate implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  owner: String!
  accountID: Int!
  tokenID: Int!
  feeBips: Int!
  tokenWeight: BigInt!
  nonce: Int!
  balance: BigInt!
}

type SignatureVerification implements Transaction @entity {
  id: ID!

  data: String!

  block: Block!

  owner: String!
  accountID: Int!
  verificationData: String!
}
